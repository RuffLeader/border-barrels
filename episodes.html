<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Episodes</title>
  <style>
/* === Base Styles === */
body {
  font-family: 'Segoe UI', sans-serif;
  color: #002157;
  margin: 0;
  padding: 0;
  line-height: 1.6;
}

.container {
  max-width: 1100px;
  margin: 0 auto;
  padding: 1rem;
  text-align: center;
}

/* Header styles */
header {
  background-color: #002157;
  color: white;
  padding: 1rem 0;  /* Same as beers.html */
  position: relative;
  z-index: 1000;
  /* Remove border-bottom */
  /* border-bottom: 2px solid #e0e0e0;  Remove this line */
}

header .container {
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: relative;
}

header h1 {
  font-size: 2.5rem;  /* Matches about.html and beers.html */
  font-weight: bold;
  text-transform: uppercase;
  margin: 1rem 0 0.5rem;
  letter-spacing: 1px;
}

footer {
  background-color: #002157;
  color: #ffffff;
  padding: 2rem 0;
  border-top: 2px solid #e0e0e0;
  font-size: 0.9rem;
  text-align: center;
}

h1 {
  font-family: 'Segoe UI', sans-serif;
  font-weight: bold;
  text-transform: uppercase;
  margin: 1rem 0;
  letter-spacing: 1px;
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
}

nav a {
  margin: 0 1rem;
  font-size: 1rem;
  color: #ffffff;
  text-decoration: none;
  padding: 0.5rem;
}

nav a:hover {
  color: #ffb400;
}

main {
  padding: 2rem;
}

/* Nav styles */
#nav-menu {
  display: flex;
  gap: 1rem;
  justify-content: center;
  list-style: none;
}

#nav-menu a {
  color: white;
  text-decoration: none;
  padding: 0.5rem 1rem;
  font-size: 1rem;
  transition: color 0.3s ease;
}

#nav-menu a:hover {
  color: #ffb400;
}

/* Burger menu button */
#nav-toggle {
  display: none;
  flex-direction: column;
  gap: 5px;
  background: none;
  border: none;
  cursor: pointer;
  z-index: 1100;
}

#nav-toggle:focus {
  outline: 2px solid #ffb400;
  outline-offset: 2px;
}

.burger {
  width: 25px;
  height: 3px;
  background: white;
  border-radius: 2px;
}

/* === Controls (Search + Sort) === */
#controls {
  display: flex;
  justify-content: center;
  align-items: center;
  flex-wrap: nowrap;
  margin: 1.5rem 0;
}

#controls input#search {
  width: 300px;
  padding: 0.6em 0.8em;
  font-size: 1rem;
  border: 1px solid #002157;
  border-radius: 4px 0 0 4px;
  outline: none;
  box-sizing: border-box;
}

#controls button#toggleOrder {
  background-color: #002157;
  color: white;
  border: 1px solid #002157;
  padding: 0.6em 1em;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 0 4px 4px 0;
  box-sizing: border-box;
}

#controls button#toggleOrder:hover {
  background-color: #004080;
  border-color: #004080;
}

#controls button#toggleOrder:active {
  background-color: #001a40;
  border-color: #001a40;
}

/* === Grid Container === */
#episode-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  justify-content: center;
  align-items: start;
  gap: 1.5rem;
  margin: 0 auto;
  padding: 1rem;
  max-width: 100vw;
  width: 100%;
  box-sizing: border-box;
}

/* Grid layout when filtered */
#episode-grid.filtered {
  grid-template-columns: repeat(auto-fit, 300px);
  justify-content: center;
}

/* Center single card */
#episode-grid.filtered.single {
  grid-template-columns: 1fr;
  justify-content: center;
}

/* === Episode Cards === */
.video-card {
  border-radius: 8px;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  max-width: 320px;
  width: 100%;
  color: #002157;
  box-sizing: border-box;
  align-items: center;
}

/* Thumbnail */
.video-card img {
  width: 100%;
  height: auto;
  aspect-ratio: 16 / 9; /* or whatever ratio matches your thumbnails */
  object-fit: cover;
  border-radius: 8px;
  margin-bottom: 0.5rem;
  display: block; /* ADD THIS */
}

/* Links section */
.links {
  margin-bottom: 0.8rem;
  display: flex;
  gap: 1rem;
  justify-content: center;
}

.links a {
  text-decoration: none;
  color: #002157;
  font-weight: bold;
  font-size: 0.9rem;
}

.links a:hover {
  text-decoration: underline;
  color: #DAA520;
}

/* === Episode Info === */
.episode-info {
  text-align: center;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
}

.episode-number {
  font-size: 1rem;
  font-weight: normal;
  color: #004080;
}

.episode-title {
  font-size: 1rem;
  font-weight: bold;
  margin: 0;
}

.description {
  font-size: 0.9rem;
  margin: 0.2rem 0;
  padding: 0 0.5rem;
  color: #002157;
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
}

.description.truncated {
  -webkit-line-clamp: 4;
}

.read-more-btn {
  margin-top: 0.5rem;
  color: #002157;
  font-size: 0.85rem;
  cursor: pointer;
  text-decoration: underline;
  background: none;
  border: none;
  padding: 0;
}

/* === Pagination Buttons === */
#pagination {
  margin: 2em 0;
  text-align: center;
}

#pagination button {
  background-color: #002157;
  color: white;
  border: 1px solid #002157;
  padding: 0.6em 1em;
  font-size: 1rem;
  cursor: pointer;
  border-radius: 4px;
  margin: 0 0.5rem;
  transition: background-color 0.2s ease, border-color 0.2s ease;
}

#pagination button:hover {
  background-color: #004080;
  border-color: #004080;
}

#pagination button:active {
  background-color: #001a40;
  border-color: #001a40;
}

/* Mobile styles */
@media (max-width: 768px) {
  #nav-toggle {
    display: flex;
  }
  #nav-menu {
    display: none;
    flex-direction: column;
    position: absolute;
    top: 100%;
    left: 0;
    width: 100%;
    background-color: #002157;
    padding: 10px 0;
    border-bottom: 2px solid #e0e0e0;
  }
  #nav-menu.show {
    display: flex;
  }
  #nav-menu a {
    padding: 0.75rem 1.5rem;
    font-size: 1.1rem;
  }
}

/* Smaller cards on mobile */
@media (max-width: 600px) {
  #episode-grid {
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
    gap: 1rem; /* slightly smaller gap */
  }

  .video-card {
    max-width: 260px; /* was 320px */
    padding: 0.75rem; /* less padding */
  }

  .video-card img {
    border-radius: 6px;
  }

  .episode-title {
    font-size: 0.95rem;
  }

  .description {
    font-size: 0.85rem;
  }
}

  </style>
</head>
<body>
  <header>
    <div class="container">
      <h1>Podcast Episodes</h1>
      <button id="nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
        <span class="burger"></span>
        <span class="burger"></span>
        <span class="burger"></span>
      </button>
      <nav id="nav-menu" class="nav-links">
        <a href="index.html">Home</a>
        <a href="beers.html">Beers</a>
        <a href="episodes.html">Episodes</a>
        <a href="about.html">About Us</a>
      </nav>
    </div>
  </header>

<div id="controls">
  <input type="text" id="search" placeholder="Search episodes..." />
  <button id="toggleOrder">Show Oldest First</button>
</div>
<div id="episode-grid"></div>
<div id="pagination"></div>

  <footer>
    <p>Â© 2025 Border Barrels</p>
  </footer>

  <script>
const container = document.getElementById("episode-grid");
const searchInput = document.getElementById("search");
const toggleButton = document.getElementById("toggleOrder");
const pagination = document.getElementById("pagination");

let episodeData = [];  // will hold data fetched from episodes.json
let filteredData = [];
let currentPage = 1;
let newestFirst = true;
let itemsPerPage = calculateEpisodesPerPage();

function updateGridClasses(filteredItemsCount) {
  container.classList.remove("no-filter", "filtered", "single");

  if (filteredItemsCount === episodeData.length) {
    container.classList.add("no-filter");
  } else {
    container.classList.add("filtered");
    if (filteredItemsCount === 1) {
      container.classList.add("single");
    }
  }
}

function calculateEpisodesPerPage() {
  const cardWidth = 300; // Approx width of each episode card (adjust if needed)
  const desiredRows = 3; // Number of rows you want to fill per page

  const cardsPerRow = Math.floor(window.innerWidth / cardWidth);
  return cardsPerRow * desiredRows;
}

// Your existing renderEpisodes, renderPagination, applySorting, etc. functions here unchanged...

function renderEpisodes(data) {
  container.innerHTML = "";
  const start = (currentPage - 1) * itemsPerPage;
  const end = start + itemsPerPage;
  const pageData = data.slice(start, end);

  pageData.forEach(ep => {
    const card = document.createElement("div");
    card.className = "video-card";

    let linksHTML = `<a href="https://www.youtube.com/watch?v=${ep.youtubeId}" target="_blank">YouTube</a>`;
    if (ep.spotifyUrl) {
      linksHTML += `<a href="${ep.spotifyUrl}" target="_blank">Spotify</a>`;
    }
    if (ep.appleUrl) {
      linksHTML += `<a href="${ep.appleUrl}" target="_blank">Apple</a>`;
    }

    card.innerHTML = `
      <img src="https://img.youtube.com/vi/${ep.youtubeId}/hqdefault.jpg" alt="Thumbnail for Episode ${ep.number}">
      <div class="links">
        ${linksHTML}
      </div>
      <div class="episode-info">
        <div class="episode-number">Episode ${ep.number}</div>
        <div class="episode-title">${ep.title}</div>
        <p class="description truncated">${ep.description}</p>
        <button class="read-more-btn">Read more</button>
      </div>
    `;

    container.appendChild(card);
  });

  updateGridClasses(filteredData.length);

  document.querySelectorAll('.video-card').forEach(card => {
    const desc = card.querySelector('.description');
    const button = card.querySelector('.read-more-btn');

    if (!desc || !button) return;

    desc.classList.remove('truncated');
    const fullHeight = desc.scrollHeight;
    desc.classList.add('truncated');
    const truncatedHeight = desc.clientHeight;

    if (fullHeight <= truncatedHeight + 1) {
      button.style.display = 'none';
    } else {
      button.style.display = 'inline-block';
    }

    button.addEventListener('click', () => {
      const expanded = !desc.classList.contains('truncated');
      desc.classList.toggle('truncated');
      button.textContent = expanded ? 'Read more' : 'Read less';
    });
  });
}

function renderPagination(dataLength) {
  pagination.innerHTML = "";
  const pageCount = Math.ceil(dataLength / itemsPerPage);

  for (let i = 1; i <= pageCount; i++) {
    const btn = document.createElement("button");
    btn.textContent = i;
    if (i === currentPage) btn.disabled = true;
    btn.addEventListener("click", () => {
      currentPage = i;
      renderEpisodes(filteredData);
      renderPagination(filteredData.length);
    });
    pagination.appendChild(btn);
  }
}

function applySorting() {
  const sorted = [...filteredData].sort((a, b) => newestFirst ? b.number - a.number : a.number - b.number);
  filteredData = sorted;
  renderEpisodes(filteredData);
  renderPagination(filteredData.length);
}

searchInput.addEventListener("input", () => {
  const searchTerm = searchInput.value.toLowerCase();
  filteredData = episodeData.filter(ep =>
    ep.title.toLowerCase().includes(searchTerm) ||
    ep.description.toLowerCase().includes(searchTerm) ||
    String(ep.number).includes(searchTerm)
  );
  currentPage = 1;
  applySorting();
});

toggleButton.addEventListener("click", () => {
  newestFirst = !newestFirst;
  toggleButton.textContent = newestFirst ? "Show Oldest First" : "Show Newest First";
  applySorting();
});

window.addEventListener('resize', () => {
  itemsPerPage = calculateEpisodesPerPage();
  renderEpisodes(filteredData);
  renderPagination(filteredData.length);
});

// NEW: Fetch episodes.json and initialize
async function init() {
  try {
    const res = await fetch('episodes.json');  // Adjust path if needed
    if (!res.ok) throw new Error('Could not load episodes.json');
    episodeData = await res.json();
    filteredData = [...episodeData];
    currentPage = 1;
    newestFirst = true;
    toggleButton.textContent = "Show Oldest First";
    applySorting();
  } catch (error) {
    container.innerHTML = `<p style="color:red;">Error loading episodes: ${error.message}</p>`;
  }
}

init();

  document.addEventListener("DOMContentLoaded", () => {
    const navToggle = document.getElementById("nav-toggle");
    const navMenu = document.getElementById("nav-menu");

    if (navToggle && navMenu) {
      navToggle.addEventListener("click", () => {
        navMenu.classList.toggle("show");

        // Update aria-expanded for accessibility
        const expanded = navToggle.getAttribute("aria-expanded") === "true";
        navToggle.setAttribute("aria-expanded", !expanded);
      });
    }
  });
</script>
</body>
</html>
